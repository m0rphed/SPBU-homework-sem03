**Задача 1:**
*Lazy*

Реализовать следующий интерфейс, представляющий ленивое вычисление:
~~~csharp
public interface ILazy<T> {
        T Get();
}
~~~
Объект Lazy создаётся на основе вычисления (представляемого объектом ```Func<T>```)
- Первый вызов ```Get()``` вызывает вычисление и возвращает результат.
- Повторные вызовы ```Get()``` возвращают тот же объект,
что и первый вызов.
- Вычисление должно запускаться не более одного раза.

Создавать объекты надо не вручную, а с помощью класса LazyFactory,
который должен иметь два метода с сигнатурами наподобие.

~~~csharp
public static Lazy<T> Create...Lazy<T>(Func<T> supplier)
~~~
Возвращающих две разные реализации ```ILazy<T>```:

- Простая версия с гарантией корректной работы в однопоточном режиме (без синхронизации).
- Гарантия корректной работы в многопоточном режиме.
    - При этом она должна по возможности минимизировать число необходимых синхронизаций
(если значение уже вычислено, не должно быть блокировок)

- supplier вправе вернуть null.

*Библиотечным Lazy пользоваться, естественно, нельзя*

Нужно:
- CI, на котором проходят ваши тесты (все и многопоточные и однопоточные)
    - Однопоточные, на разные хорошие и плохие случаи
    - Многопоточные, на наличие гонок